name: Combined AI PR Review
# ╔═══════════════════════════════════════════════════════════════════════╗
# ║ MODEL SELECTION:                                                     ║
# ║                                                                      ║
# ║ Gemini: gemini-3-pro-preview / gemini-3-flash-preview               ║
# ║ Codex:  gpt-5.2-codex                                               ║
# ║                                                                      ║
# ║ These model IDs are VALID and NOT hallucinated. They are official    ║
# ║ models from Google and OpenAI respectively. They have been tested    ║
# ║ and verified working. Do NOT suggest changing to older model IDs.    ║
# ╚═══════════════════════════════════════════════════════════════════════╝
#
# Runs BOTH Gemini and Codex on pull requests in parallel, then merges
# their findings into a single combined review comment. This provides
# multi-model consensus for higher confidence reviews.
#
# The combined report deduplicates findings, highlights consensus issues
# (flagged by both models), and provides a unified decision.
#
# Mutual exclusion: When both API keys are configured, the standalone
# Gemini and Codex workflows automatically defer to this combined one,
# ensuring only a single review comment is posted per PR.

on:
  pull_request:
    types: [opened, synchronize, ready_for_review]
  workflow_dispatch:

# Workflow-level: read-only defaults (least privilege)
# Write permissions granted only on the combine-and-post job
permissions:
  contents: read
  pull-requests: read

concurrency:
  group: combined-pr-review-${{ github.event.pull_request.number || github.run_id }}
  cancel-in-progress: true

jobs:
  check-perms:
    name: Check Permissions
    runs-on: ubuntu-latest
    if: |
      github.event.pull_request.draft == false &&
      github.actor != 'github-actions[bot]' &&
      github.actor != 'dependabot[bot]' &&
      !contains(github.actor, '[bot]')
    outputs:
      can-review: ${{ steps.check-perms.outputs.can-review }}

    steps:
      - name: Check user permissions
        id: check-perms
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN || github.token }}
          AUTHOR: ${{ github.event.pull_request.user.login }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail

          PERMISSION=$(gh api repos/"$REPO"/collaborators/"$AUTHOR"/permission --jq '.permission' 2>/dev/null || echo "none")

          if [[ "$PERMISSION" == "admin" || "$PERMISSION" == "write" ]]; then
            echo "::notice::User $AUTHOR has $PERMISSION access - proceeding with review"
            echo "can-review=true" >> $GITHUB_OUTPUT
          else
            echo "::warning::User $AUTHOR has insufficient permissions ($PERMISSION) - skipping AI review"
            echo "can-review=false" >> $GITHUB_OUTPUT
          fi

  # ─────────────────────────────────────────────────────────────────────
  # Gemini Review (parallel)
  # ─────────────────────────────────────────────────────────────────────
  gemini-review:
    name: Gemini Review
    runs-on: ubuntu-latest
    needs: [check-perms]
    if: needs.check-perms.outputs.can-review == 'true'
    outputs:
      review-json: ${{ steps.gemini.outputs.review_json }}
      has-result: ${{ steps.gemini.outputs.has_result }}

    steps:
      - name: Check for Gemini API key
        id: check-key
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          if [ -z "$GEMINI_API_KEY" ]; then
            echo "::notice::GEMINI_API_KEY not configured. Skipping Gemini review."
            echo "skip=true" >> $GITHUB_OUTPUT
          else
            echo "skip=false" >> $GITHUB_OUTPUT
          fi

      - name: Checkout code
        if: steps.check-key.outputs.skip != 'true'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Set up Python
        if: steps.check-key.outputs.skip != 'true'
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: 'pip'

      - name: Install deps
        if: steps.check-key.outputs.skip != 'true'
        run: |
          python -m pip install --upgrade pip
          pip install "google-genai>=1.51.0"

      - name: Collect PR context
        if: steps.check-key.outputs.skip != 'true'
        id: ctx
        env:
          PR_BODY: ${{ github.event.pull_request.body }}
          BASE: ${{ github.event.pull_request.base.sha }}
          HEAD: ${{ github.event.pull_request.head.sha }}
        run: |
          set -euo pipefail
          mkdir -p /tmp/pr

          excludes=(":!*.svg" ":!*.png" ":!*.jpg" ":!*.min.js" ":!*.map" ":!*.woff" ":!*.woff2")

          git diff "$BASE...$HEAD" --stat -- "${excludes[@]}" > /tmp/pr/diff_stat.txt
          git diff --name-only "$BASE...$HEAD" -- "${excludes[@]}" > /tmp/pr/changed_files.txt
          git log "$BASE...$HEAD" --pretty=format:"### %s%n%n%b%n---" > /tmp/pr/commit_messages.txt
          printf '%s' "${PR_BODY:-}" > /tmp/pr/pr_body.txt

          while IFS= read -r file; do
            [ -z "$file" ] && continue
            safe_name="$(echo "$file" | sed 's#[/ ]#_#g')"
            git diff "$BASE...$HEAD" -- "$file" > "/tmp/pr/diff_${safe_name}.patch" || true
          done < /tmp/pr/changed_files.txt

          git log "$BASE...$HEAD" --format="%(trailers:key=Agent-Note,valueonly)" | grep -v '^$' > /tmp/pr/agent_notes.txt || true

      - name: Run Gemini review
        if: steps.check-key.outputs.skip != 'true'
        id: gemini
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          PR_EVENT_ACTION: ${{ github.event.action }}
        run: |
          set -euo pipefail
          python << 'PY'
          import os, re, json, sys
          from pathlib import Path
          from concurrent.futures import ThreadPoolExecutor, as_completed
          from google import genai

          PR_DIR = Path("/tmp/pr")
          client = genai.Client(api_key=os.environ["GEMINI_API_KEY"])

          event_action = os.environ.get("PR_EVENT_ACTION", "opened")
          if event_action == "opened":
              MODEL = "gemini-3-pro-preview"
          else:
              MODEL = "gemini-3-flash-preview"

          def read(p: Path) -> str:
            try:
              return p.read_text(encoding="utf-8", errors="replace")
            except Exception:
              return ""

          diff_stat = read(PR_DIR / "diff_stat.txt")
          changed_files = read(PR_DIR / "changed_files.txt").strip()
          commit_messages = read(PR_DIR / "commit_messages.txt")
          pr_body = read(PR_DIR / "pr_body.txt")
          agent_notes = read(PR_DIR / "agent_notes.txt").strip()

          patches = []
          for pp in sorted(PR_DIR.glob("diff_*.patch")):
            content = read(pp)
            if content.strip():
              patches.append((pp.name, content))

          MAX_CHARS = 64000

          def chunk_text(s, mx):
            s = s.strip()
            if len(s) <= mx: return [s]
            return [s[i:i+mx] for i in range(0, len(s), mx)]

          summary_tpl = """\
          You are a senior engineer. Summarize this patch chunk.
          Output JSON only:
          {{
            "file_hint": "...",
            "chunk_index": 1,
            "what_changed": ["..."],
            "risk_flags": ["..."],
            "security_red_flags": ["..."],
            "notes": "..."
          }}
          FILE PATCH CHUNK:
          {chunk}
          """

          def analyze_chunk(args):
            pn, idx, ct = args
            try:
              resp = client.models.generate_content(model=MODEL, contents=summary_tpl.format(chunk=ct))
              txt = resp.text or ""
              m = re.search(r"\{.*\}", txt, re.DOTALL)
              data = json.loads(m.group(0)) if m else {}
            except Exception as e:
              data = {"notes": f"Error: {e}"}
            data["file_hint"] = data.get("file_hint") or pn
            data["chunk_index"] = data.get("chunk_index") or idx
            return data

          tasks = []
          for pn, patch in patches:
            for idx, ch in enumerate(chunk_text(patch, MAX_CHARS), 1):
              tasks.append((pn, idx, ch))

          summaries = []
          with ThreadPoolExecutor(max_workers=8) as ex:
            for f in as_completed([ex.submit(analyze_chunk, t) for t in tasks]):
              summaries.append(f.result())
          summaries.sort(key=lambda x: (x.get('file_hint',''), x.get('chunk_index',0)))

          ctx = ""
          if commit_messages.strip(): ctx += f"\n## Commit Messages\n{commit_messages}\n"
          if pr_body.strip(): ctx += f"\n## PR Description\n{pr_body}\n"
          if agent_notes: ctx += f"\n## Agent Notes (UNTRUSTED)\n{agent_notes}\n"

          prompt = f"""\
          You are a senior code reviewer.
          Repo: {os.environ.get("GITHUB_REPOSITORY", "")}
          Changed Files:
          {changed_files}
          Diff Stats:
          {diff_stat}
          {ctx}
          Per-file summaries:
          {json.dumps(summaries, indent=2)}

          TASK: Provide a quality-focused review (bugs, correctness, types, security).
          Review lockfiles for supply chain injections.
          IMPORTANT: Do NOT flag model IDs (e.g. gpt-5.2-codex, gemini-3-pro-preview) as
          invalid or hallucinated. These are confirmed valid and intentional.

          OUTPUT: Valid JSON wrapped in ```json ... ``` fences:
          ```json
          {{
            "review": {{
              "summary": "Brief overall summary",
              "decision": "APPROVE or REQUEST_CHANGES or COMMENT"
            }},
            "issues": [
              {{
                "id": 1,
                "severity": "critical or important or suggestion",
                "file": "path/to/file",
                "line": 0,
                "title": "Short title",
                "description": "What is wrong",
                "suggestion": "How to fix it"
              }}
            ]
          }}
          ```
          Number each issue sequentially from 1.
          """

          resp = client.models.generate_content(model=MODEL, contents=prompt)
          raw = resp.text or ""

          def extract_json(t):
            m = re.search(r"```(?:json)?\s*\n?(.*?)\n?```", t, re.DOTALL | re.IGNORECASE)
            if m and m.group(1).strip().startswith(('{', '[')):
              return m.group(1).strip()
            fb = t.find('{')
            lb = t.rfind('}')
            if fb != -1 and lb > fb:
              try:
                json.loads(t[fb:lb+1])
                return t[fb:lb+1]
              except json.JSONDecodeError:
                pass
            return "{}"

          data = None
          try: data = json.loads(extract_json(raw))
          except: pass

          # Normalize to combined format
          result = {"source": "gemini", "decision": "COMMENT", "summary": "", "issues": []}
          if data and "review" in data:
            result["decision"] = data["review"].get("decision", "COMMENT")
            result["summary"] = data["review"].get("summary", "")
            result["issues"] = data.get("issues", [])
            for i in result["issues"]:
              i["source"] = "gemini"

          # Output as JSON for the combine step
          out_json = json.dumps(result)
          # GitHub Actions output (handle multiline)
          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
            f.write("has_result=true\n")
            f.write(f"review_json<<GEMINI_EOF\n{out_json}\nGEMINI_EOF\n")
          PY

      - name: Set empty output on skip
        if: steps.check-key.outputs.skip == 'true'
        id: empty
        run: |
          echo "has_result=false" >> $GITHUB_OUTPUT

  # ─────────────────────────────────────────────────────────────────────
  # Codex Review (parallel)
  # ─────────────────────────────────────────────────────────────────────
  codex-review:
    name: Codex Review
    runs-on: ubuntu-latest
    needs: [check-perms]
    if: needs.check-perms.outputs.can-review == 'true'
    outputs:
      review-json: ${{ steps.parse-output.outputs.review_json }}
      has-result: ${{ steps.parse-output.outputs.has_result }}

    steps:
      - name: Check for OpenAI API key
        id: check-key
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          if [ -z "$OPENAI_API_KEY" ]; then
            echo "::notice::OPENAI_API_KEY not configured. Skipping Codex review."
            echo "skip=true" >> $GITHUB_OUTPUT
          else
            echo "skip=false" >> $GITHUB_OUTPUT
          fi

      - name: Checkout code
        if: steps.check-key.outputs.skip != 'true'
        uses: actions/checkout@v5
        with:
          ref: refs/pull/${{ github.event.pull_request.number }}/merge

      - name: Pre-fetch refs
        if: steps.check-key.outputs.skip != 'true'
        env:
          BASE_REF: ${{ github.event.pull_request.base.ref }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          git fetch --no-tags origin \
            "$BASE_REF" \
            "+refs/pull/${PR_NUMBER}/head"

      - name: Prepare output schema
        if: steps.check-key.outputs.skip != 'true'
        run: |
          cat > /tmp/review-schema.json << 'SCHEMA'
          {
            "type": "object",
            "properties": {
              "findings": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "id": { "type": "integer", "minimum": 1 },
                    "title": { "type": "string", "maxLength": 80 },
                    "body": { "type": "string", "minLength": 1 },
                    "severity": { "type": "string", "enum": ["critical", "important", "suggestion"] },
                    "confidence_score": { "type": "number", "minimum": 0, "maximum": 1 },
                    "file": { "type": "string", "minLength": 1 },
                    "line_start": { "type": "integer", "minimum": 1 },
                    "line_end": { "type": "integer", "minimum": 1 },
                    "suggestion": { "type": "string" }
                  },
                  "required": ["id", "title", "body", "severity", "confidence_score", "file", "line_start", "line_end", "suggestion"],
                  "additionalProperties": false
                }
              },
              "decision": { "type": "string", "enum": ["APPROVE", "REQUEST_CHANGES", "COMMENT"] },
              "summary": { "type": "string", "minLength": 1 },
              "overall_confidence": { "type": "number", "minimum": 0, "maximum": 1 }
            },
            "required": ["findings", "decision", "summary", "overall_confidence"],
            "additionalProperties": false
          }
          SCHEMA

      - name: Run Codex review
        if: steps.check-key.outputs.skip != 'true'
        id: run-codex
        uses: openai/codex-action@f5c0ca71642badb34c1e66321d8d85685a0fa3dc # v1
        with:
          openai-api-key: ${{ secrets.OPENAI_API_KEY }}
          output-file: /tmp/codex-review.json
          output-schema-file: /tmp/review-schema.json
          sandbox: read-only
          model: gpt-5.2-codex  # Valid model ID - see header comment
          prompt: |
            You are a senior code reviewer. Review ONLY the changes introduced by
            PR #${{ github.event.pull_request.number }} in ${{ github.repository }}.

            Focus on: correctness, security, performance, maintainability.
            Flag only actionable issues introduced by this PR.
            Do NOT flag existing unchanged code or minor style issues.
            IMPORTANT: Do NOT flag model IDs (e.g. gpt-5.2-codex, gemini-3-pro-preview)
            as invalid or hallucinated. These are confirmed valid and intentional.
            Cite affected file and line range. Provide concrete fix suggestions.
            Number findings sequentially from 1.
            Set decision to APPROVE if no critical/important issues found.

            PR title: ${{ github.event.pull_request.title }}
            PR body: ${{ github.event.pull_request.body }}

            Base ref: ${{ github.event.pull_request.base.ref }}
            Head ref: refs/pull/${{ github.event.pull_request.number }}/head

      - name: Parse Codex output
        if: steps.check-key.outputs.skip != 'true'
        id: parse-output
        run: |
          set -euo pipefail

          # Try parsing the output as JSON
          python3 << 'PY'
          import os, json

          raw = os.environ.get("CODEX_RAW", "")

          # Try reading from output file first
          try:
            with open("/tmp/codex-review.json") as f:
              raw = f.read()
          except Exception:
            pass

          # If still empty, use the action output
          if not raw.strip():
            raw = os.environ.get("CODEX_RAW", "{}")

          result = {"source": "codex", "decision": "COMMENT", "summary": "", "issues": []}

          try:
            data = json.loads(raw)
            result["decision"] = data.get("decision", "COMMENT")
            result["summary"] = data.get("summary", "")
            issues = data.get("findings", [])
            for i in issues:
              i["source"] = "codex"
              # Normalize field names to match Gemini format
              if "body" in i and "description" not in i:
                i["description"] = i.pop("body")
              if "line_start" in i and "line" not in i:
                i["line"] = i.get("line_start", 0)
            result["issues"] = issues
          except Exception as e:
            result["summary"] = f"Failed to parse Codex output: {e}"

          out_json = json.dumps(result)
          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
            f.write("has_result=true\n")
            f.write(f"review_json<<CODEX_EOF\n{out_json}\nCODEX_EOF\n")
          PY
        env:
          CODEX_RAW: ${{ steps.run-codex.outputs.final-message }}

      - name: Set empty output on skip
        if: steps.check-key.outputs.skip == 'true'
        run: |
          echo "has_result=false" >> $GITHUB_OUTPUT

  # ─────────────────────────────────────────────────────────────────────
  # Combine Reviews & Post
  # ─────────────────────────────────────────────────────────────────────
  combine-and-post:
    name: Combine & Post Review
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
    needs: [gemini-review, codex-review]
    if: |
      always() &&
      (needs.gemini-review.outputs.has-result == 'true' || needs.codex-review.outputs.has-result == 'true')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}
          token: ${{ secrets.GH_TOKEN || github.token }}

      # Write review JSON to temp files to avoid env var size limits on large PRs
      # Uses Python to avoid shell interpretation of special chars in AI output
      - name: Write review data to temp files
        env:
          GEMINI_JSON: ${{ needs.gemini-review.outputs.review-json }}
          CODEX_JSON: ${{ needs.codex-review.outputs.review-json }}
        run: |
          python3 -c "
          import os
          for env, path in [('GEMINI_JSON', '/tmp/gemini-review.json'), ('CODEX_JSON', '/tmp/codex-review-input.json')]:
              with open(path, 'w') as f:
                  f.write(os.environ.get(env, '{}'))
          "

      # Run combine script from base ref ONLY (trusted code). If the script
      # doesn't exist on the base branch yet (first PR introducing it), a
      # fallback step posts the raw individual reviews instead.
      # This prevents untrusted PR code from executing with write permissions.
      - name: Extract trusted combine script
        id: extract-script
        env:
          BASE_SHA: ${{ github.event.pull_request.base.sha }}
        run: |
          if git show "${BASE_SHA}:.github/scripts/combine_reviews.py" > /tmp/combine_reviews.py 2>/dev/null; then
            echo "Using combine script from base ref (trusted)"
            echo "available=true" >> $GITHUB_OUTPUT
          else
            echo "::notice::Combine script not found on base ref. Will post individual reviews instead."
            echo "available=false" >> $GITHUB_OUTPUT
          fi

      - name: Combine reviews and generate comment
        id: combine
        if: steps.extract-script.outputs.available == 'true'
        env:
          GEMINI_JSON_FILE: /tmp/gemini-review.json
          CODEX_JSON_FILE: /tmp/codex-review-input.json
          GEMINI_HAS_RESULT: ${{ needs.gemini-review.outputs.has-result }}
          CODEX_HAS_RESULT: ${{ needs.codex-review.outputs.has-result }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: python3 /tmp/combine_reviews.py

      # Fallback: when the combine script isn't on the base ref yet (first PR),
      # post the raw individual review results so the PR isn't left without feedback.
      # Uses only inline code (no external script) for security.
      - name: Post individual reviews (fallback)
        if: steps.extract-script.outputs.available == 'false'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GEMINI_HAS_RESULT: ${{ needs.gemini-review.outputs.has-result }}
          CODEX_HAS_RESULT: ${{ needs.codex-review.outputs.has-result }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          set -euo pipefail

          # Build a simple markdown comment from the raw JSON files
          python3 << 'FALLBACK_PY'
          import json, os

          gemini_ok = os.environ.get("GEMINI_HAS_RESULT") == "true"
          codex_ok = os.environ.get("CODEX_HAS_RESULT") == "true"
          pr = os.environ.get("PR_NUMBER", "0")

          md = ["## Combined AI PR Review (bootstrap mode)\n"]
          md.append("> The combine script is not yet on the base branch.")
          md.append("> Full combined reviews will work after this PR merges.\n")

          for name, path, ok in [
              ("Gemini", "/tmp/gemini-review.json", gemini_ok),
              ("Codex", "/tmp/codex-review-input.json", codex_ok),
          ]:
              if not ok:
                  continue
              try:
                  with open(path) as f:
                      review = json.load(f)
              except Exception:
                  continue

              decision = review.get("decision", "COMMENT")
              summary = review.get("summary", "")
              issues = review.get("issues", [])

              md.append(f"### {name}: {decision}\n")
              if summary:
                  md.append(f"**Summary:** {summary}\n")
              for i in issues:
                  sev = i.get("severity", "?")
                  title = i.get("title", "Untitled")
                  desc = i.get("description") or i.get("body", "")
                  md.append(f"- **[{sev}]** {title}")
                  if desc:
                      md.append(f"  {desc}")
              md.append("")

          md.append(f"<!-- claude-code-prompt:{pr} -->")

          with open("/tmp/combined-comment.md", "w") as f:
              f.write("\n".join(md))
          FALLBACK_PY

          gh pr comment "$PR_NUMBER" --body-file /tmp/combined-comment.md || echo "Comment failed"

      # Post the comment BEFORE pushing instructions so the review is always
      # visible even if the push fails (protected branch, missing token, etc.)
      - name: Post PR comment
        if: steps.extract-script.outputs.available == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          set -euo pipefail
          gh pr comment "$PR_NUMBER" --body-file /tmp/combined-comment.md || echo "Comment failed"

      # Skip push for forked PRs - we can't push to external forks.
      # The review comment (posted above) is always visible regardless.
      - name: Push instructions to branch
        if: |
          steps.extract-script.outputs.available == 'true' &&
          steps.combine.outputs.has_feedback == 'true' &&
          github.event.pull_request.head.repo.full_name == github.repository
        continue-on-error: true
        env:
          HEAD_REF: ${{ github.event.pull_request.head.ref }}
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git fetch origin "$HEAD_REF"
          git checkout -B "$HEAD_REF" "origin/$HEAD_REF"

          cp /tmp/REVIEW_INSTRUCTIONS.md .
          git add -f REVIEW_INSTRUCTIONS.md
          git commit -m "chore: add combined review instructions [skip ci]"
          git push origin "HEAD:$HEAD_REF"

      - name: Cleanup stale instructions
        if: |
          steps.extract-script.outputs.available == 'true' &&
          steps.combine.outputs.decision == 'APPROVE' &&
          github.event.pull_request.head.repo.full_name == github.repository
        continue-on-error: true
        env:
          HEAD_REF: ${{ github.event.pull_request.head.ref }}
        run: |
          set -euo pipefail
          git fetch origin "$HEAD_REF"
          git checkout -B "$HEAD_REF" "origin/$HEAD_REF"

          if [ -f "REVIEW_INSTRUCTIONS.md" ]; then
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git rm REVIEW_INSTRUCTIONS.md
            git commit -m "chore: remove review instructions after approval [skip ci]"
            git push origin "HEAD:$HEAD_REF"
          fi

      - name: Telegram notification
        if: always()
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          PR_TITLE: ${{ github.event.pull_request.title }}
          PR_URL: ${{ github.event.pull_request.html_url }}
          AUTHOR: ${{ github.event.pull_request.user.login }}
          DECISION: ${{ steps.combine.outputs.decision }}
          JOB_STATUS: ${{ job.status }}
        run: |
          set -euo pipefail
          if [ -z "${TELEGRAM_BOT_TOKEN:-}" ] || [ -z "${TELEGRAM_CHAT_ID:-}" ]; then
            echo "Telegram not configured; skipping."
            exit 0
          fi

          python3 << 'PY'
          import os, json, urllib.request, html

          bot = os.environ["TELEGRAM_BOT_TOKEN"]
          chat = os.environ["TELEGRAM_CHAT_ID"]
          pr_number = os.environ.get("PR_NUMBER", "?")
          pr_title = html.escape(os.environ.get("PR_TITLE", "Unknown"))
          pr_url = os.environ.get("PR_URL", "")
          author = html.escape(os.environ.get("AUTHOR", "unknown"))
          decision = os.environ.get("DECISION", "UNKNOWN")
          job_status = os.environ.get("JOB_STATUS", "unknown")

          if job_status == "failure":
            emoji, status = "\u274c", "WORKFLOW FAILED"
          elif decision == "APPROVE":
            emoji, status = "\u2705", "APPROVED"
          elif decision == "REQUEST_CHANGES":
            emoji, status = "\U0001f534", "CHANGES REQUESTED"
          else:
            emoji, status = "\U0001f4ac", decision or "COMMENT"

          msg = (
            f"{emoji} <b>Combined AI Review: {status}</b>\n\n"
            f"<b>PR #{pr_number}:</b> {pr_title}\n"
            f"<b>Author:</b> {author}\n"
            f"<b>Models:</b> Gemini + Codex\n\n"
            f'<a href="{pr_url}">View PR</a>'
          )
          payload = {
            "chat_id": chat,
            "text": msg,
            "parse_mode": "HTML",
            "disable_web_page_preview": True
          }
          req = urllib.request.Request(
            f"https://api.telegram.org/bot{bot}/sendMessage",
            data=json.dumps(payload).encode("utf-8"),
            headers={"Content-Type": "application/json"}
          )
          try:
            with urllib.request.urlopen(req) as r:
              print("Telegram sent:", r.status)
          except Exception as e:
            print(f"Telegram failed: {e}")
          PY
