"""
Database models and session management for the Economist module.

Provides SQLAlchemy ORM models for cloud costs, optimization
recommendations, governance policies, and policy violations.
"""

from __future__ import annotations

import uuid
from datetime import date, datetime
from typing import Any, Generator

from sqlalchemy import (
    Boolean,
    Column,
    Date,
    DateTime,
    Float,
    Index,
    Integer,
    String,
    Text,
    create_engine,
    func,
)
from sqlalchemy.dialects.postgresql import JSONB, UUID
from sqlalchemy.orm import Session, declarative_base, sessionmaker

from pkg.config import get_settings

Base = declarative_base()


# ---------------------------------------------------------------------------
# ORM Models
# ---------------------------------------------------------------------------


class CloudCost(Base):
    """Represents a single cloud cost line item."""

    __tablename__ = "cloud_costs"

    id: str = Column(
        UUID(as_uuid=True), primary_key=True, default=uuid.uuid4
    )
    provider: str = Column(String(32), nullable=False, index=True)
    service: str = Column(String(128), nullable=False, index=True)
    resource_id: str = Column(String(256), nullable=False)
    resource_name: str = Column(String(256), nullable=True)
    cost_usd: float = Column(Float, nullable=False)
    currency: str = Column(String(8), nullable=False, default="USD")
    usage_quantity: float = Column(Float, nullable=True)
    usage_unit: str = Column(String(64), nullable=True)
    region: str = Column(String(64), nullable=True, index=True)
    account_id: str = Column(String(128), nullable=True, index=True)
    tags: dict = Column(JSONB, nullable=True)
    date: date = Column(Date, nullable=False, index=True)
    created_at: datetime = Column(
        DateTime(timezone=True), server_default=func.now(), nullable=False
    )

    __table_args__ = (
        Index("ix_cloud_costs_provider_date", "provider", "date"),
        Index("ix_cloud_costs_service_date", "service", "date"),
    )

    def to_dict(self) -> dict[str, Any]:
        return {
            "id": str(self.id),
            "provider": self.provider,
            "service": self.service,
            "resource_id": self.resource_id,
            "resource_name": self.resource_name,
            "cost_usd": self.cost_usd,
            "currency": self.currency,
            "usage_quantity": self.usage_quantity,
            "usage_unit": self.usage_unit,
            "region": self.region,
            "account_id": self.account_id,
            "tags": self.tags,
            "date": self.date.isoformat() if self.date else None,
            "created_at": (
                self.created_at.isoformat() if self.created_at else None
            ),
        }


class OptimizationRecommendation(Base):
    """A cost optimization recommendation generated by the engine."""

    __tablename__ = "optimization_recommendations"

    id: str = Column(
        UUID(as_uuid=True), primary_key=True, default=uuid.uuid4
    )
    provider: str = Column(String(32), nullable=False, index=True)
    resource_id: str = Column(String(256), nullable=False)
    resource_type: str = Column(String(128), nullable=False)
    recommendation_type: str = Column(String(64), nullable=False, index=True)
    title: str = Column(String(512), nullable=False)
    description: str = Column(Text, nullable=True)
    estimated_monthly_savings: float = Column(Float, nullable=False, default=0.0)
    confidence: float = Column(Float, nullable=False, default=0.0)
    status: str = Column(
        String(32), nullable=False, default="open", index=True
    )
    created_at: datetime = Column(
        DateTime(timezone=True), server_default=func.now(), nullable=False
    )
    resolved_at: datetime = Column(DateTime(timezone=True), nullable=True)

    def to_dict(self) -> dict[str, Any]:
        return {
            "id": str(self.id),
            "provider": self.provider,
            "resource_id": self.resource_id,
            "resource_type": self.resource_type,
            "recommendation_type": self.recommendation_type,
            "title": self.title,
            "description": self.description,
            "estimated_monthly_savings": self.estimated_monthly_savings,
            "confidence": self.confidence,
            "status": self.status,
            "created_at": (
                self.created_at.isoformat() if self.created_at else None
            ),
            "resolved_at": (
                self.resolved_at.isoformat() if self.resolved_at else None
            ),
        }


class GovernancePolicy(Base):
    """A governance policy that defines cost/resource rules."""

    __tablename__ = "governance_policies"

    id: str = Column(
        UUID(as_uuid=True), primary_key=True, default=uuid.uuid4
    )
    name: str = Column(String(256), nullable=False, unique=True)
    description: str = Column(Text, nullable=True)
    policy_type: str = Column(String(64), nullable=False, index=True)
    rules: dict = Column(JSONB, nullable=False)
    severity: str = Column(
        String(32), nullable=False, default="warning", index=True
    )
    enabled: bool = Column(Boolean, nullable=False, default=True)
    created_at: datetime = Column(
        DateTime(timezone=True), server_default=func.now(), nullable=False
    )
    updated_at: datetime = Column(
        DateTime(timezone=True),
        server_default=func.now(),
        onupdate=func.now(),
        nullable=False,
    )

    def to_dict(self) -> dict[str, Any]:
        return {
            "id": str(self.id),
            "name": self.name,
            "description": self.description,
            "policy_type": self.policy_type,
            "rules": self.rules,
            "severity": self.severity,
            "enabled": self.enabled,
            "created_at": (
                self.created_at.isoformat() if self.created_at else None
            ),
            "updated_at": (
                self.updated_at.isoformat() if self.updated_at else None
            ),
        }


class PolicyViolation(Base):
    """Records a detected governance policy violation."""

    __tablename__ = "policy_violations"

    id: str = Column(
        UUID(as_uuid=True), primary_key=True, default=uuid.uuid4
    )
    policy_id: str = Column(
        UUID(as_uuid=True), nullable=False, index=True
    )
    resource_id: str = Column(String(256), nullable=False)
    provider: str = Column(String(32), nullable=False, index=True)
    description: str = Column(Text, nullable=True)
    severity: str = Column(String(32), nullable=False, default="warning")
    detected_at: datetime = Column(
        DateTime(timezone=True), server_default=func.now(), nullable=False
    )
    resolved_at: datetime = Column(DateTime(timezone=True), nullable=True)

    def to_dict(self) -> dict[str, Any]:
        return {
            "id": str(self.id),
            "policy_id": str(self.policy_id),
            "resource_id": self.resource_id,
            "provider": self.provider,
            "description": self.description,
            "severity": self.severity,
            "detected_at": (
                self.detected_at.isoformat() if self.detected_at else None
            ),
            "resolved_at": (
                self.resolved_at.isoformat() if self.resolved_at else None
            ),
        }


# ---------------------------------------------------------------------------
# Engine / Session helpers
# ---------------------------------------------------------------------------

_engine = None
_SessionLocal = None


def init_engine(database_url: str | None = None) -> None:
    """Create the SQLAlchemy engine and session factory.

    Call this once at application startup.
    """
    global _engine, _SessionLocal

    if database_url is None:
        database_url = get_settings().postgres_url

    _engine = create_engine(
        database_url,
        pool_size=10,
        max_overflow=20,
        pool_pre_ping=True,
        echo=False,
    )
    _SessionLocal = sessionmaker(bind=_engine, autocommit=False, autoflush=False)


def create_tables() -> None:
    """Create all tables that do not yet exist."""
    if _engine is None:
        raise RuntimeError("Database engine not initialized. Call init_engine() first.")
    Base.metadata.create_all(bind=_engine)


def get_session() -> Generator[Session, None, None]:
    """Yield a database session and ensure it is closed afterwards.

    Intended for use as a FastAPI dependency::

        @app.get("/items")
        def read_items(db: Session = Depends(get_session)):
            ...
    """
    if _SessionLocal is None:
        raise RuntimeError("Database engine not initialized. Call init_engine() first.")
    session = _SessionLocal()
    try:
        yield session
    finally:
        session.close()


def get_engine():
    """Return the current SQLAlchemy engine instance."""
    return _engine
