# ⚠️ REVIEW INSTRUCTIONS

> Generated by Gemini

```json
{
  "review": {
    "summary": "This PR implements a complex AI Ops platform but introduces Critical security and stability blockers. The API Gateway (Cerebra) currently has an authentication bypass and fatal race conditions in its routing and budgeting logic. The Backup service (Aegis) is architected to hold full archives in memory, causing OOM risks. These must be fixed before merging.",
    "decision": "REQUEST_CHANGES"
  },
  "issues": [
    {
      "id": 1,
      "severity": "critical",
      "file": "cerebra/internal/middleware/middleware.go",
      "line": 15,
      "title": "Authentication Bypass in API Gateway",
      "description": "The `AuthMiddleware` validates API keys solely by checking if `len(apiKey) < 16`. There is no check against a database, hash map, or environment variable. Any arbitrary string of 16+ characters grants full access to the paid LLM proxy.",
      "suggestion": "Implement actual validation against the `organizations` or `agents` database tables (preferably via a cached hash) to ensure the key is valid and active."
    },
    {
      "id": 2,
      "severity": "critical",
      "file": "cerebra/internal/router/router.go",
      "line": 45,
      "title": "Fatal Race Condition in Router Metrics",
      "description": "The `UpdateMetrics` method modifies the `r.metrics` map and its entries without any mutex locking. Since `r.metrics` is shared across all requests, concurrent traffic will cause a 'concurrent map read and map write' panic, crashing the service.",
      "suggestion": "Add a `sync.RWMutex` to the `Router` struct and acquire a Lock/RLock when accessing `r.metrics`."
    },
    {
      "id": 3,
      "severity": "critical",
      "file": "cerebra/internal/budget/enforcer.go",
      "line": 60,
      "title": "Fatal Race Condition in Budget Alerts",
      "description": "The `alertsSent` map is accessed and modified in `checkAlertThresholds` without locking. As budget checks happen on every request, this causes a race condition that will panic the application.",
      "suggestion": "Protect `alertsSent` with a `sync.Mutex`."
    },
    {
      "id": 4,
      "severity": "important",
      "file": "aegis/internal/backup/manager.go",
      "line": 85,
      "title": "Out-Of-Memory (OOM) Risk in Backup Creation",
      "description": "`createArchive` writes the entire tarball to an in-memory `bytes.Buffer`. `ExecuteBackup` then passes this `[]byte` slice to the storage layer. For large backups (e.g., many resources or inclusion of large configmaps/secrets), this will exhaust container memory and kill the pod.",
      "suggestion": "Refactor the `StorageBackend` interface to accept an `io.Reader` instead of `[]byte`. Stream the archive generation directly to the storage writer using `io.Pipe`."
    },
    {
      "id": 5,
      "severity": "important",
      "file": "cerebra/internal/proxy/handler.go",
      "line": 110,
      "title": "Broken Auth Propagation in Proxy",
      "description": "The proxy explicitly deletes the `X-API-Key` header from the incoming request in `copyRequestHeaders` but does not appear to inject the platform's own upstream API key (e.g., for OpenAI/Anthropic) before forwarding. Unless the upstream provider accepts unauthenticated requests (unlikely), the proxy will fail.",
      "suggestion": "Inject the appropriate upstream provider API key (from environment variables or secure configuration) into the request headers before forwarding."
    },
    {
      "id": 6,
      "severity": "important",
      "file": "cerebra/internal/proxy/handler.go",
      "line": 55,
      "title": "Blocking I/O breaks LLM Streaming",
      "description": "The handler reads the full response body using `io.ReadAll`. This prevents Server-Sent Events (SSE) streaming from working, which is standard for LLM interactions. It also doubles memory pressure.",
      "suggestion": "Implement a streaming proxy that copies the response body to the client writer as it is received, rather than buffering it entirely."
    },
    {
      "id": 7,
      "severity": "important",
      "file": ".github/workflows/onefilellm.yml",
      "line": 40,
      "title": "Insufficient SSRF Protection",
      "description": "The regex-based blocklist for IPs (`127\\.`, `169\\.254\\.`, etc.) fails to block alternative IP representations (e.g., `2130706433` for 127.0.0.1, octal `0177.0.0.1`) or DNS rebinding attacks. This allows the workflow to be used to scan internal network resources.",
      "suggestion": "Use a dedicated tool with robust SSRF protection or run the fetcher in a network-restricted container that cannot access private address ranges."
    },
    {
      "id": 8,
      "severity": "suggestion",
      "file": ".claude/hooks/auto-approve.sh",
      "line": 25,
      "title": "Unsafe Auto-Approval of Test Runners",
      "description": "The hook automatically approves commands starting with `pytest` and `cargo test`. In many environments, running tests executes arbitrary code (e.g., `build.rs`, `conftest.py`). If the agent is used in an untrusted repository, this is immediate RCE.",
      "suggestion": "Remove test runners from the auto-approve list or restrict them to specific safe arguments/directories."
    }
  ]
}
```